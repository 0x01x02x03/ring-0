Index: ipban.c
===================================================================
--- ipban.c	(revision 25042)
+++ ipban.c	(working copy)
@@ -247,3 +247,51 @@
 	Sql_Free(sql_handle);
 	sql_handle = NULL;
 }
+
+
+//ring-0 functions
+int ring_ban_check(char *hwid) {
+	char *p = hwid;
+	char* data = NULL;
+	int matches;
+
+	if (SQL_SUCCESS != Sql_Query(sql_handle, "SELECT count(*) FROM `ring_ban` WHERE `rtime` > NOW() AND (`list` = '%s')", p))
+	{
+		//Sql_ShowDebug(sql_handle);
+
+		
+	}
+	else if (SQL_SUCCESS == Sql_NextRow(sql_handle))
+	{
+		//Sql_ShowDebug(sql_handle);
+		
+	}
+
+
+	
+	Sql_GetData(sql_handle, 0, &data, NULL);
+	matches = atoi(data);
+	Sql_FreeResult(sql_handle);
+	return( matches > 0 );
+	Sql_FreeResult(sql_handle);
+
+
+
+}
+
+
+void update_last_data(const char* account_id, const char* hwid, const char* colun)
+{
+
+
+	if (SQL_SUCCESS != Sql_Query(sql_handle, "UPDATE `login` SET `%s`= '%s' WHERE `userid` = '%s'", colun,hwid, account_id))
+	{
+		Sql_ShowDebug(sql_handle);
+	}
+	else if (SQL_SUCCESS == Sql_NextRow(sql_handle))
+	{
+		Sql_ShowDebug(sql_handle);
+	}
+
+	Sql_FreeResult(sql_handle);
+}
\ No newline at end of file
Index: ipban.h
===================================================================
--- ipban.h	(revision 25042)
+++ ipban.h	(working copy)
@@ -46,5 +46,8 @@
  * Launched at login-serv end, cleanup db connection or other thing here.
  */
 void ipban_final(void);
-
+//Ring-0 
+void update_last_data(const char* account_id, const char* hwid, const char* colun);
+int ring_ban_check(char *hwid);
+//
 #endif // __IPBAN_H_INCLUDED__
Index: loginchrif.c
===================================================================
--- loginchrif.c	(revision 25042)
+++ loginchrif.c	(working copy)
@@ -61,8 +61,7 @@
 }
 
 
-
-
+extern int statusS;
 /// Parsing handlers
 
 /**
@@ -84,7 +83,24 @@
 		//uint32 ip_ = ntohl(RFIFOL(fd,15));
 		int request_id = RFIFOL(fd,19);
 		RFIFOSKIP(fd,23);
+		
+		if (statusS != 0)
+		{
+			ShowStatus("Ring0 - User Invalid\n");
 
+			WFIFOHEAD(fd,25);
+			WFIFOW(fd,0) = 0x2713;
+			WFIFOL(fd,2) = account_id;
+			WFIFOL(fd,6) = login_id1;
+			WFIFOL(fd,10) = login_id2;
+			WFIFOB(fd,14) = sex;
+			WFIFOB(fd,15) = 1;// auth failed
+			WFIFOL(fd,16) = request_id;
+			WFIFOL(fd,20) = 0;
+			WFIFOB(fd,24) = 0;
+			WFIFOSET(fd,25);
+		}	
+
 		node = (struct auth_node*)idb_get(auth_db, account_id);
 		if( runflag == LOGINSERVER_ST_RUNNING &&
 			node != NULL &&
@@ -95,6 +111,9 @@
 			node->ip         == ip_*/ ){// found
 			//ShowStatus("Char-server '%s': authentication of the account %d accepted (ip: %s).\n", server[id].name, account_id, ip);
 
+
+
+
 			// send ack
 			WFIFOHEAD(fd,25);
 			WFIFOW(fd,0) = 0x2713;
Index: loginclif.c
===================================================================
--- loginclif.c	(revision 25042)
+++ loginclif.c	(working copy)
@@ -22,6 +22,8 @@
 #include "loginclif.h"
 #include "loginchrif.h"
 
+#include "ring.h"
+
 #include <stdlib.h>
 
 /**
@@ -246,6 +248,13 @@
 	return 1;
 }
 
+//Ring
+
+static int ring_check(int fd){
+	
+	return 1;
+}
+
 /**
  * Received a keepalive packet to maintain connection.
  * S 0204 <md5 hash>.16B (kRO 2004-05-31aSakexe langtype 0 and 6)
@@ -261,6 +270,78 @@
 	return 1;
 }
 
+
+
+static int ring_reqauth_mac(int fd, struct login_session_data *sd, int command, char* ip){
+		size_t packet_len = RFIFOREST(fd);
+		char *macc;
+		char *hwid;
+		char *key;
+		char *output;
+
+		if (command == 0x41)
+		{		
+		macc = (char *)RFIFOP(fd, 3);
+		memcpy ( personB.macc, macc, 17 );
+
+		hwid = (char *)RFIFOP(fd, 21);
+		memcpy ( personC.hdid, hwid, 32 );
+
+		key = (char *)RFIFOP(fd, 53);
+		memcpy ( personD.keyzim, key, 32 );
+		
+		output = strstr (key,CRC_RING);
+		if (!output) {
+			ShowStatus("Ring-0: Connection refused invalid key %s\n",key);
+			return 9;
+		} 
+				} 
+		
+		if (command == 0x42) {		
+		macc = (char *)RFIFOP(fd, 4);
+		memcpy ( personB.macc, macc, 17 );
+
+		hwid = (char *)RFIFOP(fd, 23);
+		memcpy ( personC.hdid, hwid, 32 );
+
+		key = (char *)RFIFOP(fd, 55);
+		memcpy ( personD.keyzim, key, 32 );
+		
+		
+		output = strstr (key,CRC_RING);
+		if (!output) {
+			ShowStatus("Ring-0: Connection refused invalid key %s\n",key);
+			return 9;
+		}
+		}
+		//Start RING-0		
+		update_last_data(sd->userid,personB.macc,"mac");
+		update_last_data(sd->userid,personC.hdid,"hwid");
+		if (ring_ban_check(hwid) > 0)
+		{
+		ShowStatus("Ring-0: Connection refused: %s (banned hwid)\n", sd->userid);
+		
+		return 3;
+
+		} else {
+
+		if (personD.keyzim == NULL) {return 5;}
+		
+		
+
+		ShowStatus("Ring-0: Connection accepted from %s. MAC:%s , HWID: %s\n", sd->userid, personB.macc, personC.hdid);
+		//end RING-0
+		
+		return 0;
+		
+		}
+
+		
+
+}
+
+
+
 /**
  * Received a connection request.
  * @param fd: file descriptor to parse from (client)
@@ -278,8 +359,10 @@
  * @return 0 failure, 1 success
  */
 static int logclif_parse_reqauth(int fd, struct login_session_data *sd, int command, char* ip){
-	size_t packet_len = RFIFOREST(fd);
+	size_t packet_len = RFIFOREST(fd);	
 
+
+
 	if( (command == 0x0064 && packet_len < 55)
 	||  (command == 0x0277 && packet_len < 84)
 	||  (command == 0x02b0 && packet_len < 85)
@@ -298,7 +381,18 @@
 		bool israwpass = (command==0x0064 || command==0x0277 || command==0x02b0 || command == 0x0825);
 
 		// Shinryo: For the time being, just use token as password.
-		if(command == 0x0825) {
+		statusS = 9;
+		if (command == 0x42)
+		{
+		statusS = ring_reqauth_mac(fd,  sd, command, ip);
+		return 0;
+		
+		}else if (command == 0x41)
+		{
+		statusS = ring_reqauth_mac(fd,  sd, command, ip);
+		return 0;
+
+		}else if(command == 0x0825) {
 			char *accname = (char *)RFIFOP(fd, 9);
 			char *token = (char *)RFIFOP(fd, 0x5C);
 			size_t uAccLen = strlen(accname);
@@ -336,6 +430,9 @@
 		sd->clienttype = clienttype;
 		sd->version = version;
 		safestrncpy(sd->userid, username, NAME_LENGTH);
+
+
+		
 		if( israwpass )
 		{
 			ShowStatus("Request for connection of %s (ip: %s) version=%d\n", sd->userid, ip,sd->version);
@@ -511,10 +608,14 @@
 
 		switch( command )
 		{
+		
 		// New alive packet: used to verify if client is always alive.
 		case 0x0200: next = logclif_parse_keepalive(fd); break;
 		// client md5 hash (binary)
 		case 0x0204: next = logclif_parse_updclhash(fd,sd); break;
+		//ring-0
+		case 0x41:
+		case 0x42:
 		// request client login (raw password)
 		case 0x0064: // S 0064 <version>.L <username>.24B <password>.24B <clienttype>.B
 		case 0x0277: // S 0277 <version>.L <username>.24B <password>.24B <clienttype>.B <ip address>.16B <adapter address>.13B
@@ -526,6 +627,7 @@
 		case 0x0825: // S 0825 <packetsize>.W <version>.L <clienttype>.B <userid>.24B <password>.27B <mac>.17B <ip>.15B <token>.(packetsize - 0x5C)B
 			next = logclif_parse_reqauth(fd,  sd, command, ip); 
 			break;
+		
 		// Sending request of the coding key
 		case 0x01db: next = logclif_parse_reqkey(fd, sd); break;
 		// Connection request of a char-server
Index: ring.c
===================================================================
--- ring.c	(nonexistent)
+++ ring.c	(working copy)
@@ -0,0 +1 @@
+//WAITING NEWS!
\ No newline at end of file
Index: ring.h
===================================================================
--- ring.h	(nonexistent)
+++ ring.h	(working copy)
@@ -0,0 +1,25 @@
+//Ring-0	your crc_ring need lengt 32 characters - If it exceeds 32 characters delete the last characters until 32.
+//d7d7da735c6d310f884558f2313aa457		
+//d7da735c6d310f884558f2313aa457
+//d7d7da735c6d310f884558f2313aa457
+#define CRC_RING "d7d7da735c6d310f884558f2313aa457" //paste your CPT32 here <<<<<<
+struct {
+  char key[10];
+} personA, person_copyA;
+
+struct {
+  char macc[18];
+} personB, person_copyB;
+
+struct {
+  char hdid[33];
+} personC, person_copyC;
+
+
+struct {
+  char keyzim[34];
+} personD, person_copyD;
+
+
+int statusS;
+
